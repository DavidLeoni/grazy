declare var Physics2DConfig: {
    CONTACT_SLOP: number;
    EFF_MASS_EPSILON: number;
    ILL_THRESHOLD: number;
    CLIP_EPSILON: number;
    BIAS_COEF: number;
    STATIC_BIAS_COEF: number;
    CONT_BIAS_COEF: number;
    CONT_STATIC_BIAS_COEF: number;
    BOUNCE_VELOCITY_THRESHOLD: number;
    STATIC_FRIC_SQ_EPSILON: number;
    POINT_BIAS_COEF: number;
    POINT_MAX_ERROR: number;
    POINT_MAX_ERROR_SQ: number;
    POINT_SLOP_SQ: number;
    POINT_LARGE_ERROR_SQ: number;
    POINT_LARGE_ERROR_BIAS: number;
    POINT_LARGE_ERROR_MAX: number;
    WELD_BIAS_COEF: number;
    WELD_MAX_LINEAR_ERROR: number;
    WELD_MAX_ANGULAR_ERROR: number;
    WELD_MAX_LINEAR_ERROR_SQ: number;
    WELD_LINEAR_SLOP_SQ: number;
    WELD_ANGULAR_SLOP_SQ: number;
    WELD_LARGE_ERROR_SQ: number;
    WELD_LARGE_ERROR_BIAS: number;
    WELD_LARGE_ERROR_MAX: number;
    ANGLE_BIAS_COEF: number;
    ANGLE_SLOP_SQ: number;
    DIST_BIAS_COEF: number;
    DIST_SLOP_SQ: number;
    DIST_LARGE_ERROR_SQ: number;
    DIST_LARGE_ERROR_BIAS: number;
    LINE_BIAS_COEF: number;
    LINE_SLOP_SQ: number;
    LINE_LARGE_ERROR_SQ: number;
    LINE_LARGE_ERROR_BIAS: number;
    PULLEY_BIAS_COEF: number;
    PULLEY_SLOP_SQ: number;
    PULLEY_LARGE_ERROR_SQ: number;
    PULLEY_LARGE_ERROR_BIAS: number;
    MIN_LINEAR_STATIC_SWEEP: number;
    MIN_ANGULAR_STATIC_SWEEP: number;
    MIN_LINEAR_BULLET_SWEEP: number;
    MIN_ANGULAR_BULLET_SWEEP: number;
    SWEEP_LIMIT: number;
    SWEEP_SLOP: number;
    MINIMUM_SWEEP_ADVANCE: number;
    MAX_SWEEP_ITER: number;
    EQUAL_SQ_VEL: number;
    ZERO_ANG_BIAS: number;
    TOI_SLIP_SCALE: number;
    DELAYED_DEATH: number;
    DELTA_ROTATION_EPSILON: number;
    SLEEP_DELAY: number;
    SLEEP_LINEAR_SQ: number;
    SLEEP_ANGULAR_SQ: number;
    CONTAINS_EPSILON: number;
    CONTAINS_SQ_EPSILON: number;
    COLLINEAR_EPSILON: number;
    COLLINEAR_SQ_EPSILON: number;
    NORMALIZE_EPSILON: number;
    NORMALIZE_SQ_EPSILON: number;
};
interface Physics2DMaterialParams {
    elasticity?: number;
    staticFriction?: number;
    dynamicFriction?: number;
    rollingFriction?: number;
    density?: number;
    userData?: any;
}
declare class Physics2DMaterial {
    static version: number;
    public _data: any;
    public userData: any;
    static defaultMaterial: Physics2DMaterial;
    public getElasticity(): number;
    public getStaticFriction(): number;
    public getDynamicFriction(): number;
    public getRollingFriction(): number;
    public getDensity(): number;
    static create(params?: Physics2DMaterialParams): Physics2DMaterial;
}
interface Physics2DObjectCallbackFn {
    (): void;
}
interface Physics2DShapeCallbackFn {
    (arbiter: Physics2DArbiter, otherShape: Physics2DShape): void;
}
interface Physics2DConstraintParams {
    frequency?: number;
    damping?: number;
    maxForce?: number;
    maxError?: number;
    removeOnBreak?: boolean;
    breakUnderError?: boolean;
    breakUnderForce?: boolean;
    stiff?: boolean;
    ignoreInteractions?: boolean;
    sleeping?: boolean;
    disabled?: boolean;
    userData?: any;
}
declare class Physics2DConstraint {
    public type: string;
    public _removeOnBreak: boolean;
    public _breakUnderError: boolean;
    public _breakUnderForce: boolean;
    public _stiff: boolean;
    public _ignoreInteractions: boolean;
    public sleeping: boolean;
    public _active: boolean;
    public dimension: number;
    public _data: any;
    public world: Physics2DWorld;
    public _islandRoot: Physics2DIslandComponent;
    public _islandRank: number;
    public _island: Physics2DIsland;
    public _isBody: boolean;
    public _wakeTime: number;
    public _woken: boolean;
    public _onBreak: Physics2DObjectCallbackFn[];
    public _onWake: Physics2DObjectCallbackFn[];
    public _onSleep: Physics2DObjectCallbackFn[];
    public _equal: boolean;
    public bodyA: Physics2DRigidBody;
    public bodyB: Physics2DRigidBody;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public _JACC: number;
    public userData: any;
    public _inWorld(): void;
    public _outWorld(): void;
    public _pairExists(b1: Physics2DRigidBody, b2: Physics2DRigidBody): boolean;
    public _wakeConnected(): void;
    public _sleepComputation(union: Physics2DDSFUnionFn): void;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    public _draw: (debug: any) => void;
    public init(con: Physics2DConstraint, params: Physics2DConstraintParams): void;
    public configure(params: Physics2DConstraintParams): void;
    public addEventListener(eventType: string, callback: Physics2DObjectCallbackFn): boolean;
    public removeEventListener(eventType: string, callback: Physics2DObjectCallbackFn): boolean;
    public wake(automated?: boolean): void;
    public sleep(): void;
    public isEnabled(): boolean;
    public isDisabled(): boolean;
    public enable(): void;
    public disable(): void;
    public getAnchorA(dst?: any): any;
    public getAnchorB(dst?: any): any;
    public setAnchorA(anchor: any): void;
    public setAnchorB(anchor: any): void;
    public rotateAnchor(data: any, body: Physics2DRigidBody, LOCAL: number, RELATIVE: number): void;
    public dtRatio(data: any, deltaTime: number): number;
    public twoBodyInWorld(): void;
    public twoBodyOutWorld(): void;
    public twoBodyPairExists(b1: Physics2DRigidBody, b2: Physics2DRigidBody): boolean;
    public twoBodyWakeConnected(): void;
    public twoBodySleepComputation(union: Physics2DDSFUnionFn): void;
    public _clearCache(): void;
    public clearCache(): void;
    public clearCache2(): void;
    public clearCache3(): void;
    public soft_params(data: any, KMASS: number, GAMMA: number, BIAS: number, deltaTime: number, breakUnderError: boolean): boolean;
    public soft_params2(data: any, KMASS: number, GAMMA: number, BIAS: number, deltaTime: number, breakUnderError: boolean): boolean;
    public soft_params3(data: any, KMASS: number, GAMMA: number, BIAS: number, deltaTime: number, breakUnderError: boolean): boolean;
    public safe_solve(data: any, KMASS: number, ERR: number, IMP: number): void;
    public safe_solve2(data: any, KMASS: number, ERR: number, IMP: number): void;
    public safe_solve3(data: any, KMASS: number, ERR: number, IMP: number): void;
    public safe_invert(data: any, KMASS: number, JACC: number): void;
    public safe_invert2(data: any, KMASS: number, JACC: number): void;
    public safe_invert3(data: any, KMASS: number, JACC: number): void;
}
declare class Physics2DCustomConstraint extends Physics2DConstraint {
    public type: string;
    public bodies: Physics2DRigidBody[];
    public _K_MASS: number;
    public _K_CHOLESKY: number;
    public _BIAS: number;
    public _J_ACC: number;
    public _VECTOR: number;
    public _JACOBIAN: number;
    public _VECTOR_TMP: number;
    public _posConsts: () => void;
    public _posError: (data: any, index: number) => void;
    public _posClamp: (data: any, index: number) => void;
    public _velClamp: (data: any, index: number) => void;
    public _jacobian: (data: any, index: number) => void;
    public _velocityOnly: boolean;
    public _inWorld(): void;
    public _outWorld(): void;
    public _pairExists(b1: Physics2DRigidBody, b2: Physics2DRigidBody): boolean;
    public _wakeConnected(): void;
    public _sleepComputation(union: Physics2DDSFUnionFn): void;
    public _clearCache(): void;
    public _cholesky(): void;
    public _transform(X: any): void;
    public _effMass(): void;
    public _preStep(deltaTime): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _applyImpulse(J: number, position?: boolean): void;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DCustomConstraint;
}
declare class Physics2DPulleyConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public _drawLink: (debug: any, x1: any, y1: any, x2: any, y2: any, nx: any, ny: any, nl: any, bias: any, scale: any, colSA: any, colSB: any) => void;
    public bodyC: Physics2DRigidBody;
    public bodyD: Physics2DRigidBody;
    public _slack: boolean;
    public getRatio(): number;
    public setRatio(ratio: number): void;
    public getLowerBound(): number;
    public getUpperBound(): number;
    public setLowerBound(lowerBound: number): void;
    public setUpperBound(upperBound: number): void;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public _ANCHOR_C: number;
    public getAnchorC(dst?: any): any;
    public setAnchorC(anchor: any): void;
    public _ANCHOR_D: number;
    public getAnchorD(dst?: any): any;
    public setAnchorD(anchor: any): void;
    public _inWorld(): void;
    public _outWorld(): void;
    public _pairExists(b1: Physics2DRigidBody, b2: Physics2DRigidBody): boolean;
    public _wakeConnected(): void;
    public _sleepComputation(union: Physics2DDSFUnionFn): void;
    public _JACC: number;
    public _posError(): void;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): boolean;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DPulleyConstraint;
}
declare class Physics2DMotorConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public getRate(): number;
    public getRatio(): number;
    public setRate(rate: number): void;
    public setRatio(ratio: number): void;
    public _JACC: number;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DMotorConstraint;
}
declare class Physics2DLineConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public getLowerBound(): number;
    public getUpperBound(): number;
    public setLowerBound(lowerBound: number): void;
    public setUpperBound(upperBound: number): void;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public getAxis(dst?: any): any;
    public setAxis(axis: any): void;
    public _JACC: number;
    public _posError(): void;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DLineConstraint;
}
declare class Physics2DDistanceConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public _slack: boolean;
    public getLowerBound(): number;
    public getUpperBound(): number;
    public setLowerBound(lowerBound: number): void;
    public setUpperBound(upperBound: number): void;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public _JACC: number;
    public _posError(): void;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DDistanceConstraint;
}
declare class Physics2DAngleConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public _drawForBody: (debug: any, x1: any, y1: any, x2: any, y2: any, nx: any, nl: any, bias: any, scale: any, colSA: any, colSB: any) => void;
    public _slack: boolean;
    public getLowerBound(): number;
    public getUpperBound(): number;
    public getRatio(): number;
    public setLowerBound(lowerBound: number): void;
    public setUpperBound(upperBound: number): void;
    public setRatio(ratio: number): void;
    public _JACC: number;
    public _posError(): void;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DAngleConstraint;
}
declare class Physics2DWeldConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public _slack: boolean;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public getPhase(): number;
    public setPhase(phase: number): void;
    public _JACC: number;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DWeldConstraint;
}
declare class Physics2DPointConstraint extends Physics2DConstraint {
    public type: string;
    public dimension: number;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public _JACC: number;
    public _preStep(deltaTime: number): boolean;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    public _iterateVel(): boolean;
    public _iteratePos(): boolean;
    static create(params): Physics2DPointConstraint;
}
interface Physics2DShapeCallbackStore {
    callback: Physics2DShapeCallbackFn;
    mask: number;
    type: number;
    deterministic: boolean;
}
declare class Physics2DShape {
    static uniqueId: number;
    public body: Physics2DRigidBody;
    public type: string;
    public sensor: boolean;
    public arbiters: Physics2DArbiter[];
    public userData: any;
    public id: number;
    public _bphaseHandle: Physics2DBroadphaseHandle;
    public _onPreSolve: Physics2DShapeCallbackStore[];
    public _events: Physics2DShapeCallbackStore[];
    public _material: Physics2DMaterial;
    public _group: number;
    public _type: number;
    public _mask: number;
    public _data: any;
    public computeArea(): number;
    public computeMasslessInertia(): number;
    public computeCenterOfMass(dst?: any): any;
    public translate(translation, skip: boolean): void;
    public _update(posX: number, posY: number, cos: number, sin: number, skipAABB?: boolean): void;
    public clone(): Physics2DShape;
    public getGroup(): number;
    public setGroup(group: number): void;
    public getMask(): number;
    public setMask(mask: number): void;
    public getMaterial(): Physics2DMaterial;
    public setMaterial(material: Physics2DMaterial): void;
    public copyCommon(from: Physics2DShape, to: Physics2DShape): void;
    public init(shape: Physics2DShape, params): void;
    static eventIndex(events: Physics2DShapeCallbackStore[], type: number, callback: Physics2DShapeCallbackFn, callbackMask: number): number;
    public addEventListener(eventType: string, callback: Physics2DShapeCallbackFn, callbackMask?: number, deterministic?: boolean): boolean;
    public removeEventListener(eventType: string, callback: Physics2DShapeCallbackFn, callbackMask?: number): boolean;
}
declare class Physics2DCircle extends Physics2DShape {
    static version: number;
    public type: string;
    constructor();
    public computeArea(): number;
    public computeMasslessInertia(): number;
    public getRadius(): number;
    public setRadius(radius: number): void;
    public getOrigin(dst?: any): any;
    public setOrigin(origin: any): void;
    public clone(): Physics2DCircle;
    public scale(scale: number): void;
    public translate(translation: any, skip?: boolean): void;
    public rotate(rotation: number): void;
    public transform(matrix: any): void;
    public _update(posX: number, posY: number, cos: number, sin: number, skipAABB?: boolean): void;
    public _validate(): void;
    public computeCenterOfMass(dst?: any): any;
    static create(params): Physics2DCircle;
}
declare class Physics2DPolygon extends Physics2DShape {
    static version: number;
    public type: string;
    constructor();
    public computeArea(): number;
    public computeMasslessInertia(): number;
    public computeCenterOfMass(dst?: any): any;
    public setVertices(vertices: any[]): void;
    public clone(): Physics2DPolygon;
    public scale(scaleX: number, scaleY?: number): void;
    public translate(translation: any, skip?: boolean): void;
    public rotate(rotation: number): void;
    public transform(matrix: any): void;
    public _update(posX: number, posY: number, cos: number, sin: number, skipAABB?: boolean): void;
    public _validate(vertices: any[]): void;
    static create(params, inVertices?): Physics2DPolygon;
}
declare class Physics2DRigidBody {
    static version: number;
    public _data: any;
    public _type: number;
    public shapes: Physics2DShape[];
    public constraints: Physics2DConstraint[];
    public world: Physics2DWorld;
    public _customMass: boolean;
    public _customInertia: boolean;
    public sleeping: boolean;
    public bullet: boolean;
    public _bullet: boolean;
    public _sweepFrozen: boolean;
    public _deferred: boolean;
    public _island: Physics2DIsland;
    public _islandRank: number;
    public _islandRoot: Physics2DIslandComponent;
    public _isBody: boolean;
    public _wakeTime: number;
    public _woken: boolean;
    public _invalidated: boolean;
    public userData: any;
    public _onWake: Physics2DObjectCallbackFn[];
    public _onSleep: Physics2DObjectCallbackFn[];
    public isDynamic(): boolean;
    public setAsDynamic(): void;
    public isStatic(): boolean;
    public setAsStatic(): void;
    public isKinematic(): boolean;
    public setAsKinematic(): void;
    public _setTypeValue(newType: number): void;
    public applyImpulse(impulse: any, position?: any): void;
    public setVelocityFromPosition(newPosition: any, newRotation: number, deltaTime: number): void;
    public transformWorldPointToLocal(src: any, dst?: any): any;
    public transformWorldVectorToLocal(src: any, dst?: any): any;
    public transformLocalPointToWorld(src: any, dst?: any): any;
    public transformLocalVectorToWorld(src: any, dst?: any): any;
    public getPosition(dst?: any): any;
    public setPosition(position?: any): any;
    public getRotation(): number;
    public setRotation(rotation: number): void;
    public getVelocity(dst?: any): any;
    public setVelocity(velocity: any): void;
    public getAngularVelocity(): number;
    public setAngularVelocity(angularVelocity: number): void;
    public getForce(dst?: any): any;
    public setForce(force: any): any;
    public getTorque(): number;
    public setTorque(torque: number): void;
    public getSurfaceVelocity(dst?: any): any;
    public setSurfaceVelocity(surfaceVelocity: any): void;
    public getMass(): number;
    public getInertia(): number;
    public setMass(mass: number): void;
    public setMassFromShapes(): void;
    public setInertia(inertia: number): void;
    public setInertiaFromShapes(): void;
    public _invalidateMassInertia(): void;
    public getLinearDrag(): number;
    public setLinearDrag(linearDrag: number): void;
    public getAngularDrag(): number;
    public setAngularDrag(angularDrag: number): void;
    public addShape(shape: Physics2DShape): boolean;
    public removeShape(shape: Physics2DShape): boolean;
    public computeMassFromShapes(): number;
    public computeInertiaFromShapes(): number;
    public wake(automated?: boolean): void;
    public sleep(): void;
    public computeLocalCenterOfMass(dst?: any): any;
    public computeWorldBounds(dst?: any): any;
    public alignWithOrigin(): void;
    public _invalidate(): void;
    public _update(): void;
    public _atRest(deltaTime: number, timeStamp: number): boolean;
    public _deltaRotation(delta: number): number;
    public _sweepIntegrate(deltaTime: number): void;
    public integrate(deltaTime: number): void;
    public addEventListener(eventType: string, callback: Physics2DObjectCallbackFn): boolean;
    public removeEventListener(eventType: string, callback: Physics2DObjectCallbackFn): boolean;
    static create(params): Physics2DRigidBody;
}
interface Physics2DCallbackFn {
    (thisShape: Physics2DShape, otherShape: Physics2DShape): void;
}
declare class Physics2DCallback {
    public thisObject: any;
    public callback: Physics2DCallbackFn;
    public time: number;
    public index: number;
    public arbiter: Physics2DArbiter;
    public next: Physics2DCallback;
    constructor();
    static pool: Physics2DCallback;
    static allocate(): Physics2DCallback;
    static deallocate(callback: Physics2DCallback): void;
}
interface Physics2DDSFUnionFn {
    (obj1: Physics2DIslandComponent, obj2: Physics2DIslandComponent): void;
}
interface Physics2DIslandComponent {
    sleeping: boolean;
    _wakeTime: number;
    _woken: boolean;
    _island: Physics2DIsland;
    _islandRoot: Physics2DIslandComponent;
    _islandRank: number;
    _isBody: boolean;
    _onWake: Physics2DObjectCallbackFn[];
    _onSleep: Physics2DObjectCallbackFn[];
}
declare class Physics2DIsland {
    public components: Physics2DIslandComponent[];
    public sleeping: boolean;
    public wakeTime: number;
    public next: Physics2DIsland;
    constructor();
    static pool: Physics2DIsland;
    static allocate(): Physics2DIsland;
    static deallocate(island): void;
}
declare class Physics2DTOIEvent {
    public next: Physics2DTOIEvent;
    public shapeA: Physics2DShape;
    public shapeB: Physics2DShape;
    public frozenA: boolean;
    public frozenB: boolean;
    public arbiter: Physics2DArbiter;
    public failed: boolean;
    public slipped: boolean;
    public staticType: boolean;
    public kinematic: boolean;
    public _data: any;
    constructor();
    static pool: Physics2DTOIEvent;
    static allocate(): Physics2DTOIEvent;
    static deallocate(toi: Physics2DTOIEvent);
}
declare class Physics2DBoxTreeBroadphaseHandle {
    public boxTreeIndex: number;
    public data: any;
    public isStatic: boolean;
    constructor();
    static pool: Physics2DBoxTreeBroadphaseHandle[];
    static allocate(): Physics2DBoxTreeBroadphaseHandle;
    static deallocate(handle: Physics2DBoxTreeBroadphaseHandle): void;
}
declare class Physics2DBoxTreeBroadphase {
    static version: number;
    public staticTree: BoxTree;
    public dynamicTree: BoxTree;
    public overlappingNodes: BoxTreeNode[];
    constructor();
    public sample(box: any, lambda: Physics2DBroadphaseSampleFn, thisObject: any): void;
    public insert(data: any, box: any, isStatic: boolean): Physics2DBoxTreeBroadphaseHandle;
    public update(handle: Physics2DBoxTreeBroadphaseHandle, box: any, isStatic?: boolean): void;
    public remove(handle: Physics2DBoxTreeBroadphaseHandle): void;
    public clear(callback, thisObject): void;
    public _clearTree(tree, callback, thisObject): void;
    public _validate(): void;
    public perform(lambda, thisObject): void;
    static create(): Physics2DBoxTreeBroadphase;
}
declare class Physics2DSweepAndPruneHandle {
    public _next: Physics2DSweepAndPruneHandle;
    public _prev: Physics2DSweepAndPruneHandle;
    public _aabb: any;
    public data: any;
    public isStatic: boolean;
    constructor();
    static pool: Physics2DSweepAndPruneHandle;
    static allocate(): Physics2DSweepAndPruneHandle;
    static deallocate(handle): void;
}
declare class Physics2DSweepAndPrune {
    static version: number;
    public _list: Physics2DSweepAndPruneHandle;
    public sample(rectangle, lambda, thisObject): void;
    public insert(data, aabb, isStatic): Physics2DSweepAndPruneHandle;
    public update(handle, aabb, isStatic): void;
    public remove(handle): void;
    public clear(callback, thisObject): void;
    public _validate(): void;
    public perform(lambda, thisObject): void;
    static create(): Physics2DSweepAndPrune;
}
declare class Physics2DContact {
    static version: number;
    public _data: any;
    public fresh: boolean;
    public _hash: number;
    public _timeStamp: number;
    public _next: Physics2DContact;
    public active: boolean;
    public virtual: boolean;
    static pool: Physics2DContact;
    static allocate(): Physics2DContact;
    static deallocate(contact: Physics2DContact): void;
    constructor();
    public getPosition(dst?: any): any;
    public getPenetration(): number;
    public getNormalImpulse(): number;
    public getTangentImpulse(): number;
}
declare class Physics2DArbiter {
    public shapeA: Physics2DShape;
    public shapeB: Physics2DShape;
    public bodyA: Physics2DRigidBody;
    public bodyB: Physics2DRigidBody;
    public sensor: boolean;
    public _next: Physics2DArbiter;
    public _retired: boolean;
    public _reverse: boolean;
    public _lazyRetired: boolean;
    public _static: boolean;
    public _state: number;
    public _createStamp: number;
    public _updateStamp: number;
    public _sleepStamp: number;
    public _timeStamp: number;
    public _createContinuous: boolean;
    public _endGenerated: number;
    public _midStep: boolean;
    public sleeping: boolean;
    public active: boolean;
    public _invalidated: boolean;
    public _data: any;
    public contacts: Physics2DContact[];
    public _userdef: number;
    public _velocity2Contact: boolean;
    public _position2Contact: boolean;
    public _contact1: Physics2DContact;
    public _contact2: Physics2DContact;
    public _faceType: number;
    constructor();
    static version: number;
    public getNormal(dst?: any): any;
    public getRollingImpulse(): number;
    public getElasticity(): number;
    public getDynamicFriction(): number;
    public getStaticFriction(): number;
    public getRollingFriction(): number;
    public setElasticity(elasticity: number): void;
    public setDynamicFriction(dynamicFriction: number): void;
    public setStaticFriction(staticFriction: number): void;
    public setRollingFriction(rollingFriction: number): void;
    public setElasticityFromShapes(): void;
    public setDynamicFrictionFromShapes(): void;
    public setStaticFrictionFromShapes(): void;
    public setRollingFrictionFromShapes(): void;
    public isStateAccepted(): boolean;
    public isStatePersistent(): boolean;
    public setAcceptedState(accepted: boolean): void;
    public setPersistentState(persistent: boolean): void;
    public _lazyRetire(ignoreShape: Physics2DShape): void;
    public _assign(s1: Physics2DShape, s2: Physics2DShape): void;
    public _retire(): void;
    public _invalidate(dontSkip?: boolean): void;
    public _validate(): void;
    public _injectContact(px: number, py: number, nx: number, ny: number, dist: number, hash: number, virtual: boolean): Physics2DContact;
    public _cleanContacts(timeStamp): boolean;
    public _preStep(deltaTime: number, timeStamp: number, continuous?: boolean): boolean;
    public _iterateVelocity(): void;
    public _refreshContactData(): void;
    public _iteratePosition(): void;
    public _warmStart(): void;
    public getImpulseForBody(body: Physics2DRigidBody, dst?: any): any;
    static pool: Physics2DArbiter;
    static allocate(): Physics2DArbiter;
    static deallocate(arb): void;
}
interface Physics2DSampler {
    store: any[];
    count: number;
    collisions: Physics2DCollisionUtils;
    sample(handle, bounds): void;
    rectangleShape?: Physics2DShape;
    circleShape?: Physics2DShape;
}
interface Physics2DRay {
    origin: any;
    direction: any;
    maxFactor: number;
}
interface Physics2DCastCallback {
    (userThis: any, ray: Physics2DRay, result: Physics2DCastResult): boolean;
}
interface Physics2DRayCast {
    minNormal: any;
    minShape: Physics2DShape;
    minFactor: number;
    userCallback: Physics2DCastCallback;
    userThis: any;
    ray: Physics2DRay;
    noInner: boolean;
    normal: any;
    sample(handle, any): void;
}
interface Physics2DCastResult {
    shape: Physics2DShape;
    hitNormal: any;
    hitPoint: any;
    factor: number;
}
interface Physics2DConvexCast {
    toi: Physics2DTOIEvent;
    minData: any;
    minShape: Physics2DShape;
    minTOIAlpha: number;
    userCallback: Physics2DCastCallback;
    userThis: any;
    deltaTime: number;
    sample(handle, any): void;
}
interface Physics2DBroadphaseHandle {
    data: any;
    isStatic: boolean;
}
interface Physics2DBroadphaseSampleFn {
    (thisObject: any, node: Physics2DBroadphaseHandle, box: any): void;
}
interface Physics2DBroadphase {
    sample(rectangle, lambda, thisObject): void;
    insert(data, aabb, isStatic): Physics2DBroadphaseHandle;
    update(handle, aabb, isStatic?: boolean): void;
    remove(handle): void;
    clear(callback, thisObject): void;
    validate(): void;
    perform(lambda, thisObject): void;
}
declare class Physics2DWorld {
    static version: number;
    public simulatedTime: number;
    public rigidBodies: Physics2DRigidBody[];
    public constraints: Physics2DConstraint[];
    public liveDynamics: Physics2DRigidBody[];
    public liveKinematics: Physics2DRigidBody[];
    public liveConstraints: Physics2DConstraint[];
    public dynamicArbiters: Physics2DArbiter[];
    public staticArbiters: Physics2DArbiter[];
    public timeStamp: number;
    public broadphase: Physics2DBroadphase;
    public velocityIterations: number;
    public positionIterations: number;
    public _islands: Physics2DIsland[];
    public _toiEvents: Physics2DTOIEvent[];
    public _deferredWake: Physics2DRigidBody[];
    public _eventTime: number;
    public _callbacks: Physics2DCallback[];
    public _midStep: boolean;
    public _deltaTime: number;
    public _gravityX: number;
    public _gravityY: number;
    public _collisions: Physics2DCollisionUtils;
    public _sampleRectangle: any;
    public _shapePointCallback: Physics2DSampler;
    public _bodyPointCallback: Physics2DSampler;
    public _shapeRectangleCallback: Physics2DSampler;
    public _bodyRectangleCallback: Physics2DSampler;
    public _rectangleQueryVertices: any[];
    public _rectangleQueryShape: Physics2DPolygon;
    public _shapeCircleCallback: Physics2DSampler;
    public _bodyCircleCallback: Physics2DSampler;
    public _circleQueryShape: Physics2DCircle;
    public _rayCast: Physics2DRayCast;
    public _convexCast: Physics2DConvexCast;
    public getGravity(dst?: any): any;
    public setGravity(gravity: any): void;
    public _addShape(shape: Physics2DShape): void;
    public _removeShape(shape: Physics2DShape, noCallbacks?: boolean): void;
    public _enabledConstraint(constraint: Physics2DConstraint): void;
    public _disabledConstraint(constraint: Physics2DConstraint): void;
    public addConstraint(constraint: Physics2DConstraint): boolean;
    public removeConstraint(constraint: Physics2DConstraint): boolean;
    public addRigidBody(body: Physics2DRigidBody): boolean;
    public removeRigidBody(body: Physics2DRigidBody, noCallbacks?: boolean): boolean;
    public clear(): void;
    public _clearArbiters(arbiters): void;
    public shapePointQuery(point: any, store: Physics2DShape[]): number;
    public bodyPointQuery(point: any, store: Physics2DRigidBody[]): number;
    public _pointQuery(callback, point, store): number;
    public shapeCircleQuery(center: any, radius: number, store: Physics2DShape[]): number;
    public bodyCircleQuery(center: any, radius: number, store: Physics2DRigidBody[]): number;
    public _circleQuery(callback, center, radius, store): number;
    public shapeRectangleQuery(aabb: any, store: Physics2DShape[]): number;
    public bodyRectangleQuery(aabb: any, store: Physics2DRigidBody[]): number;
    public _rectangleQuery(callback, aabb, store);
    public rayCast(ray: Physics2DRay, noInnerSurfaces: boolean, customCallback, thisObject): Physics2DCastResult;
    public convexCast(shape: Physics2DShape, deltaTime: number, customCallback, thisObject): Physics2DCastResult;
    public step(deltaTime: number): void;
    public _discreteCollisions(): void;
    public _doDeferredWake(continuous: boolean): void;
    public _collisionType(s1: Physics2DShape, s2: Physics2DShape, b1: Physics2DRigidBody, b2: Physics2DRigidBody): boolean;
    public _discreteNarrowPhase(handleA: Physics2DBroadphaseHandle, handleB: Physics2DBroadphaseHandle, continuous: boolean): Physics2DArbiter;
    public _continuousCollisions(deltaTime: number): void;
    public _continuousNarrowPhase(handleA: Physics2DBroadphaseHandle, handleB: Physics2DBroadphaseHandle): void;
    public __union(x: Physics2DIslandComponent, y: Physics2DIslandComponent): void;
    public __find(x: Physics2DIslandComponent): Physics2DIslandComponent;
    public _sleepComputations(deltaTime: number): void;
    public _sortArbiters(): void;
    public _subSortArbiters(arbiters: Physics2DArbiter[]): void;
    public _onWakeCallbacks(component: Physics2DIslandComponent): void;
    public _pushCallbacks(thisObject: any, callbacks: Physics2DObjectCallbackFn[]): void;
    public _pushInteractionEvents(eventType: number, arb: Physics2DArbiter): void;
    public _brokenConstraint(con: Physics2DConstraint): void;
    public _preStep(deltaTime: number): void;
    public _preStepArbiter(arb: Physics2DArbiter, deltaTime: number, progressEvents?: boolean): void;
    public _preStepArbiters(arbiters: Physics2DArbiter[], deltaTime: number): void;
    public _iterateVelocity(count: number): void;
    public _iterateVelocityArbiters(arbiters: Physics2DArbiter[]): void;
    public _iteratePosition(count: number): void;
    public _iteratePositionArbiters(arbiters: Physics2DArbiter[]): void;
    public _integrateVelocity(deltaTime: number): void;
    public _integratePosition(deltaTime: number): void;
    public _integratePositionBodies(bodies: Physics2DRigidBody[], deltaTime: number): void;
    public _finalize(): void;
    public _finalizeArbiters(arbiters: Physics2DArbiter[]): void;
    public _finalizeBodies(bodies: Physics2DRigidBody[]): void;
    public _doCallbacks(): void;
    public _warmStart(): void;
    public _warmStartArbiters(arbiters: Physics2DArbiter[]): void;
    public _forceSleepBody(body: Physics2DRigidBody): void;
    public _forceSleepConstraint(constraint: Physics2DConstraint): void;
    public _wakeConstraint(constraint: Physics2DConstraint, noCallback?: boolean): void;
    public _wakeBody(body: Physics2DRigidBody, noCallback?: boolean, continuousCallbacks?: boolean): void;
    public _wakeArbiter(arb: Physics2DArbiter, continuousCallbacks?: boolean): void;
    public _continuousArbiterPrepare(arb: Physics2DArbiter, deltaTime: number, progressEvents?: boolean): void;
    public _wakeArbiters(arbiters: Physics2DArbiter[], skip: boolean, continuousCallbacks: boolean): void;
    public _wakeIsland(island: Physics2DIsland, noCallbackObject: Physics2DIslandComponent, continuousCallbacks?: boolean): void;
    public _transmitBodyType(body: Physics2DRigidBody, newType: number): void;
    public _validate(): void;
    public _validateBodies(bodies: Physics2DRigidBody[]): void;
    static create(params): Physics2DWorld;
}
declare class Physics2DCollisionUtils {
    public _toi: Physics2DTOIEvent;
    public containsPoint(shape: Physics2DShape, point: any): boolean;
    public signedDistance(shapeA: Physics2DShape, shapeB: Physics2DShape, witnessA: any, witnessB: any, axis: any): number;
    public intersects(shapeA: Physics2DShape, shapeB: Physics2DShape): boolean;
    public rayTest(shape: Physics2DShape, ray: Physics2DRay, normal: any, ignoreInnerSurfaces: boolean): number;
    public sweepTest(shapeA: Physics2DShape, shapeB: Physics2DShape, deltaTime: number, point: any, normal: any): number;
    public _rayTest(shape, ray, normal, noInner);
    public _rayTestPolygon(poly, ray, normal, noInner);
    public _rayTestCircle(circle, ray, normal, noInner): number;
    public _contains(shape, x, y): boolean;
    public _containsCircle(circle, x, y): boolean;
    public _containsPolygon(poly, x, y): boolean;
    public _dynamicSweep(toi: Physics2DTOIEvent, timeStep: number, negRadius: number, slowSweep?: boolean): number;
    public _staticSweep(toi: Physics2DTOIEvent, timeStep: number, negRadius?): number;
    public _distance(shapeA, shapeB, toiData): number;
    public _distanceCircle2Circle(circleA, circleB, toiData): number;
    public _distanceCircle2Polygon(circle, polygon, toiData): number;
    public _distancePolygon2Polygon(polyA, polyB, toiData): number;
    public _collide(shapeA, shapeB, arb): boolean;
    public _collideCircle2Polygon(circle, polygon, arb, reverse): boolean;
    public _collidePolygon2Polygon(polyA, polyB, arb): boolean;
    public _collideCircle2Circle(circleA, circleB, arb): boolean;
    public _test(shapeA, shapeB): boolean;
    public _testCircle2Circle(circleA, circleB): boolean;
    public _testCircle2Polygon(circle, polygon): boolean;
    public _testPolygon2Polygon(polyA, polyB): boolean;
    static create(): Physics2DCollisionUtils;
}
declare class Physics2DDevice {
    static version: number;
    public vendor: string;
    public floatArray: any;
    public uint16Array: any;
    public getDefaultMaterial(): Physics2DMaterial;
    public createCircleShape(params): Physics2DCircle;
    public createPolygonShape(params): Physics2DPolygon;
    public createRigidBody(params): Physics2DRigidBody;
    public createWorld(params): Physics2DWorld;
    public createMaterial(params: Physics2DMaterialParams): Physics2DMaterial;
    public createSweepAndPruneBroadphase(): Physics2DSweepAndPrune;
    public createBoxTreeBroadphase(): Physics2DBoxTreeBroadphase;
    public createCollisionUtils(): Physics2DCollisionUtils;
    public createPointConstraint(params): Physics2DPointConstraint;
    public createWeldConstraint(params): Physics2DWeldConstraint;
    public createAngleConstraint(params): Physics2DAngleConstraint;
    public createDistanceConstraint(params): Physics2DDistanceConstraint;
    public createLineConstraint(params): Physics2DLineConstraint;
    public createMotorConstraint(params): Physics2DMotorConstraint;
    public createPulleyConstraint(params): Physics2DPulleyConstraint;
    public createCustomConstraint(params): Physics2DCustomConstraint;
    public createRectangleVertices(minX, minY, maxX, maxY): any[];
    public createBoxVertices(width, height): any[];
    public createRegularPolygonVertices(diameterX, diameterY, numVertices): any[];
    static create(): Physics2DDevice;
}
declare class Physics2DDebugDraw {
    static version: number;
    private _width;
    private _height;
    private _invalidated;
    private _graphicsDevice;
    private _screenPort;
    private _screenPortEnabled;
    private _physics2DPort;
    private _physics2DPortEnabled;
    public physics2DToScreen: number;
    public screenToPhysics2D: number;
    public circleMaxError: number;
    public curveMaxError: number;
    public spiralMaxArc: number;
    public spiralEpsilon: number;
    public spiralSpringSize: number;
    private _curveStack;
    private _curveVerts;
    public minSpringLength: number;
    public showConstraints: boolean;
    public constraintAnchorRadius: number;
    public constraintSpringRadius: number;
    public constraintSpringNumCoils: number;
    public constraintSpiralMinRadius: number;
    public constraintSpiralDeltaRadius: number;
    public constraintSpiralNumCoils: number;
    public constraintColorA: any;
    public constraintSleepingColorA: any;
    public constraintColorB: any;
    public constraintSleepingColorB: any;
    public constraintColorC: any;
    public constraintSleepingColorC: any;
    public constraintColorD: any;
    public constraintSleepingColorD: any;
    public constraintErrorColorA: any;
    public constraintErrorSleepingColorA: any;
    public constraintErrorColorB: any;
    public constraintErrorSleepingColorB: any;
    public constraintErrorColorC: any;
    public constraintErrorSleepingColorC: any;
    public constraintErrorColorD: any;
    public constraintErrorSleepingColorD: any;
    public showContacts: boolean;
    public showContactImpulses: boolean;
    public contactRadius: number;
    public contactImpulseScale: number;
    public dynamicContactColor: any;
    public staticContactColor: any;
    public normalImpulseColor: any;
    public frictionImpulseColor: any;
    public showRigidBodies: boolean;
    public showColliderShapes: boolean;
    public showSensorsShapes: boolean;
    public showBodyDetail: boolean;
    public showShapeDetail: boolean;
    public bodyPositionRadius: number;
    public circleOriginRadius: number;
    public bodyDetailColor: any;
    public shapeDetailColor: any;
    private _colors;
    private _techniqueParams;
    private _technique;
    private _vertexBufferParameters;
    private _vertexBuffer;
    private _semantics;
    private _indexBufferParameters;
    private _indexBuffer;
    private _vertexData;
    private _indexData;
    private _numVertices;
    private _numLines;
    public setPhysics2DViewport(viewport): void;
    public setScreenViewport(viewport: any): void;
    public drawLine(x1, y1, x2, y2, color): void;
    public drawLinearSpring(x1, y1, x2, y2, numCoils, radius, color): void;
    public _drawAngleIndicator(x, y, ang, rad, size, color): void;
    public _drawAnchor(x, y, rad, color): void;
    public drawSpiral(x, y, ang1, ang2, rad1, rad2, color): void;
    public drawSpiralSpring(x, y, ang1, ang2, rad1, rad2, numCoils, color): void;
    public drawCurve(x1, y1, cx, cy, x2, y2, color): void;
    public drawRectangle(x1, y1, x2, y2, color): void;
    public drawCircle(x, y, radius, color): void;
    public drawRigidBody(body): void;
    public drawConstraint(con): void;
    public drawWorld(world): void;
    public _drawArbiters(arbiters): void;
    public _drawShape(shape): void;
    public _drawCircleShape(circle, color): void;
    public _drawPolygonShape(polygon, color): void;
    public begin(): void;
    public end(): void;
    public _prepare(numVerts, numLines): void;
    public _bufferSizeAlgorithm(target): number;
    public _dispatch(): void;
    public destroy(): void;
    static create(params): Physics2DDebugDraw;
}
interface BoxTreeRay {
    origin: any;
    direction: any;
    maxFactor: number;
}
interface BoxTreeRayTestResult {
    factor: number;
}
interface BoxTreeRayTestCallback {
    (tree, externalNode, ray: BoxTreeRay, distance, upperBound): BoxTreeRayTestResult;
}
declare class BoxTreeNode {
    static version: number;
    public escapeNodeOffset: number;
    public externalNode: {};
    public extents: number[];
    constructor(extents, escapeNodeOffset, externalNode);
    public isLeaf(): boolean;
    public reset(minX, minY, maxX, maxY, escapeNodeOffset, externalNode?): void;
    public clear(): void;
    static create(extents, escapeNodeOffset, externalNode?): BoxTreeNode;
}
declare class BoxTree {
    static version: number;
    public nodes: BoxTreeNode[];
    public endNode: number;
    public needsRebuild: boolean;
    public needsRebound: boolean;
    public numAdds: number;
    public numUpdates: number;
    public numExternalNodes: number;
    public startUpdate: number;
    public endUpdate: number;
    public highQuality: boolean;
    public numNodesLeaf: number;
    public arrayConstructor: any;
    constructor(highQuality: boolean);
    public add(externalNode, extents): void;
    public remove(externalNode): void;
    public findParent(nodeIndex);
    public update(externalNode, extents): void;
    public needsFinalize(): boolean;
    public finalize(): void;
    public rebound(): void;
    public rebuild(): void;
    public sortNodes(nodes): void;
    public sortNodesHighQuality(nodes): void;
    public calculateSAH(buildNodes, startIndex, endIndex): number;
    public nthElement(nodes, first, nth, last, getkey): void;
    public recursiveBuild(buildNodes, startIndex, endIndex, lastNodeIndex): void;
    public getVisibleNodes(planes, visibleNodes): void;
    public getOverlappingNodes(queryExtents, overlappingNodes, startIndex): number;
    public getCircleOverlappingNodes(center, radius, overlappingNodes): void;
    public getOverlappingPairs(overlappingPairs, startIndex): number;
    public getRootNode(): BoxTreeNode;
    public getNodes(): BoxTreeNode[];
    public getEndNodeIndex(): number;
    public clear(): void;
    static rayTest(trees: BoxTree[], ray: BoxTreeRay, callback: BoxTreeRayTestCallback): BoxTreeRayTestResult;
    static create(highQuality): BoxTree;
}
