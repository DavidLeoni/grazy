interface DeferredEffectTypeData extends EffectPrepareObject {
    shaderName: string;
    techniqueName: string;
    update(camera: Camera);
    loadTechniques(shaderManager: ShaderManager);
    shadowMappingShaderName?: string;
    shadowMappingTechniqueName?: string;
    shadowMappingUpdate?: (camera: Camera, md: MathDevice) => void;
}
declare class DeferredRendering {
    static version: number;
    public minPixelCount: number;
    public md: MathDevice;
    public black: any;
    public numPasses: number;
    public passIndex: {
        opaque: number;
        decal: number;
        transparent: number;
        shadow?: number;
    };
    public passes: any[][];
    public globalTechniqueParameters: TechniqueParameters;
    public sharedTechniqueParameters: TechniqueParameters;
    public mixTechniqueParameters: TechniqueParameters;
    public techniqueParameters: TechniqueParameters;
    public node: SceneNode;
    public lightPrimitive: number;
    public quadPrimitive: number;
    public lightSemantics: Semantics;
    public quadSemantics: Semantics;
    public spotLightVolumeVertexBuffer: VertexBuffer;
    public pointLightVolumeVertexBuffer: VertexBuffer;
    public quadVertexBuffer: VertexBuffer;
    public deferredShader: Shader;
    public bufferWidth: number;
    public bufferHeight: number;
    public opaqueRenderables: any[];
    public decalRenderables: any[];
    public transparentRenderables: any[];
    public localDirectionalLights: LightInstance[];
    public spotLights: LightInstance[];
    public pointLights: LightInstance[];
    public fogLights: LightInstance[];
    public ambientLightTechnique: Technique;
    public ambientDirectionalLightTechnique: Technique;
    public directionalLightTechnique: Technique;
    public spotLightTechnique: Technique;
    public pointLightTechnique: Technique;
    public pointLightSpecularTechnique: Technique;
    public pointLightSpecularOpaqueTechnique: Technique;
    public fogLightTechnique: Technique;
    public mixTechnique: Technique;
    public spotLightShadowTechnique: Technique;
    public pointLightSpecularShadowTechnique: Technique;
    public pointLightSpecularShadowOpaqueTechnique: Technique;
    public shadowMaps: ShadowMapping;
    public sceneMaxDistance: number;
    public sceneExtents: any;
    public sceneGlobalLights: LightInstance[];
    public globalCameraMatrix: any;
    public lightProjection: any;
    public mixRenderTarget: RenderTarget;
    public lightingRenderTarget: RenderTarget;
    public baseRenderTarget: RenderTarget;
    public depthBuffer: RenderBuffer;
    public depthTexture: Texture;
    public finalTexture: Texture;
    public specularLightingTexture: Texture;
    public diffuseLightingTexture: Texture;
    public normalTexture: Texture;
    public specularTexture: Texture;
    public albedoTexture: Texture;
    public defaultSkinBufferSize: number;
    public ft: number;
    public sm: number;
    public defaultUpdateFn: (camera: Camera) => void;
    public defaultSkinnedUpdateFn: (camera: Camera) => void;
    public defaultPrepareFn: (geometryInstance: GeometryInstance) => void;
    public defaultShadowMappingUpdateFn: (camera: Camera) => void;
    public defaultShadowMappingSkinnedUpdateFn: (camera: Camera) => void;
    public loadTechniquesFn: (shaderManager: ShaderManager) => void;
    public updateShader(sm): void;
    public sortRenderablesAndLights(camera, scene): void;
    public update(gd, camera, scene, currentTime): void;
    public lightFindVisibleRenderables(lightInstance, scene): boolean;
    public destroyBuffers(): void;
    public updateBuffers(gd, deviceWidth, deviceHeight): boolean;
    public pixelCountCompare(nodeA, nodeB): number;
    public draw(gd, clearColor, drawDecalsFn, drawTransparentFn, drawDebugFn, postFXsetupFn): void;
    public setLightingScale(scale): void;
    public getDefaultSkinBufferSize(): number;
    public destroy(): void;
    static create(gd, md, shaderManager, effectManager, settings): DeferredRendering;
}
